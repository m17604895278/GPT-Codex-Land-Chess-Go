🧠 一、总体状态机

整个游戏可以抽象成 3 个大状态：

WAITING  →  PLAYING  →  FINISHED


含义：

WAITING：等待玩家匹配 / 进入房间

PLAYING：正在对局

FINISHED：对局结束

🧩 二、WAITING（等待阶段）
状态：WAITING

触发条件：

房间创建

玩家1进入

等待玩家2

事件：

玩家加入房间

转移条件：

当玩家数 == 2
    → 初始化棋盘
    → 随机摆棋
    → turn = 随机一方
    → 状态切换为 PLAYING

🎮 三、PLAYING（对局阶段）

PLAYING 状态内部可以再细分为：

PLAYING
 ├── TURN_START
 ├── WAIT_INPUT
 ├── APPLY_ACTION
 ├── CHECK_RESULT
 └── SWITCH_TURN

1️⃣ TURN_START（回合开始）

做的事：

确认当前回合玩家

等待该玩家输入操作

进入：

WAITING → PLAYING
或
SWITCH_TURN → TURN_START

2️⃣ WAIT_INPUT（等待操作）

玩家可发送两种操作：

flip（翻棋）

move（走棋）

非法操作：

非当前玩家发操作

操作类型不是 flip / move

处理：

收到合法操作 → APPLY_ACTION
收到非法操作 → 返回 error，仍停留在 WAIT_INPUT

3️⃣ APPLY_ACTION（执行操作）

分两种：

A. flip 操作

翻开指定棋子

若玩家阵营未确定：

用该棋子阵营确定玩家阵营

对方阵营自动确定

更新棋盘状态

B. move 操作

校验：

是否己方棋子

是否已翻开

是否可移动

如果目标为空 → 普通移动

如果目标有敌棋 → 进入吃子判定

4️⃣ CHECK_RESULT（结果判断）

判断：

是否有军旗被吃？

是否一方无可移动棋子？

若满足结束条件：

→ FINISHED


否则：

→ SWITCH_TURN

5️⃣ SWITCH_TURN（切换回合）

处理：

turn = 对方阵营

step++

转移：

→ TURN_START

🏁 四、FINISHED（结束阶段）
状态：FINISHED

触发条件：

一方军旗被吃

或一方无棋可走

处理：

设置 winner

推送 game_over 消息

房间状态标记 finished

可选：

写数据库

清理内存

回收房间

🔄 五、完整状态流（串起来）
WAITING
  ↓ (2人就绪)
PLAYING
  ↓
TURN_START
  ↓
WAIT_INPUT
  ↓
APPLY_ACTION
  ↓
CHECK_RESULT
  ↓───────────────┐
  │               │
  │ 若未结束      │
  ↓               │
SWITCH_TURN       │
  ↓               │
TURN_START ◄──────┘
  ↓
若结束 → FINISHED

🧠 六、异常分支（必须考虑）
❌ 非当前回合操作
WAIT_INPUT → error → WAIT_INPUT

❌ 非法 move / flip
WAIT_INPUT → error → WAIT_INPUT

⚡ 掉线
PLAYING → 暂停 or 等待重连
（不改变状态机主流程）

🎯 七、状态机设计核心原则

任何输入必须落在状态机节点上

只有 APPLY_ACTION 能改变棋盘状态

只有 CHECK_RESULT 能进入 FINISHED

所有状态变化由服务端驱动
